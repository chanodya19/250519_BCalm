---
title: "BCalm: A User's Guide"
author: "Pia Keukeleire"
date: "`r format(Sys.time(), '%B %d, %Y')`"
package: "`r Githubpkg('kircherlab/bcalm')` (v0.1.0)"
bibliography: bcalm.bib
abstract: >
  A presentation of how the `BCalm` package should be used for massively parallel reporter assays (MPRA) data analysis.
vignette: >
  %\VignetteIndexEntry{BCalm: A User's Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r remotes installation, echo=TRUE}
install.packages("remotes", repos='http://cran.us.r-project.org', dependencies=TRUE)
remotes::install_github("kircherlab/bcalm@fix/installation")
```

```{r loading packages, echo=TRUE}
library(BCalm)
library(dplyr)
library(ggplot2)
library(kableExtra) # for visual appealing tables
```

# Introduction

The `r Githubpkg('kircherlab/bcalm')` package provides a framework for analyzing data from Massively Parallel Reporter Assays (MPRA) and is built on top of the mpra package. BCalm adapts the existing mpralm method but enhances it by modeling individual barcode counts rather than aggregating counts per sequence. Furthermore, the package includes a set of pre-processing functions and plotting capabilities, facilitating the visualization and interpretation of results. Especially without prior outlier removal BCalm is more robust. Variant and element analysis are both shown below together with a significance test of elements against a control group (e.g. negative controls).

## How to appreciate the work
The work presented here is currently within a peer review process and is based on the `mpra` package [@mpralm] and hence on the voom framework [@voom]. Which can be appreciated by citing the respective manuscripts.

## Additional information for the installation
The package is currently available as a github package which default branch is the BC_modification branch and installable using remotes [@remotes]. The `remotes` package needs to be installed first and the most appropriate cran mirror can be changed using the repos parameter, a list of mirrors can be found [here](https://cran.r-project.org/mirrors.html).
If you have any trouble with the provided package feel free to let us know by creating an issue directly in the [BCalm github repository](https://github.com/kircherlab/BCalm).

# Preprossing data

The first dataframe contains lentiMPRA data performed within HepG2 cells (cell line of epithelial-like morphology isolated from a hepatocellular carcinoma of a 15-year-old) with three technical replicates (IGVF accession identifier: IGVFSM9009DVDG). Sequences tested in this experiment aim at capturing variant effects across tens of thousands of candidate cis-regulatory element (cCRE) sequences of 200 base pair (bp) length. The cCREs were selected from ENCODE DNase peak calls across multiple cell-lines, and only elements located within 650 to 20,000 base pairs upstream of gene transcriptional start sites (TSSs) were included. A small subset of this library is used within this vignette.
The files to be shown here were obtained from a Snakemake workflow produced as part of the Impact of Genomic Variation on Function Consortium which is called `r Githubpkg('kircherlab/MPRAsnakeflow')`, it is a comprehensive pipeline able to perform both the assignment of barcodes to the designed oligos and, the preparation of count tables of DNA and RNA counts based on the observed number of barcodes within the targeted DNA and RNA sequencing (modified from [@Gordon2020]).

```{r First dataset}
data("BcSetExample")
nr_reps = 3
# show the data
kable(head(BcSetExample), "html") %>% kable_styling("striped") %>% scroll_box(width = "100%")
```

In general, any sequences can be tested within a specific cell type using an MPRA experiment. Possible analyses can be differentiated according to whether the activities of the sequences are first grouped and then compared. This is referred to as element testing, because the respective sequences are then grouped as coherent regulatory elements according to properties such as their genomic origin or their sequence content, and these groups are then compared. Here, the sequences were grouped and compared according to negative control (known to have low activity in the cell type) and the sequences to be tested. 
Another possibility is to compare sequences that differ in only one or a few bases and thus determine a variant effect. Examples of both of these possibilities are shown below, where it is first shown how the expected structure of the data can be created using this package.

## Variant testing

To prepare data for variant testing, we use the `create_var_df` function from BCalm. This function requires a mapping dataframe with information linking each reference allele to its corresponding alternative allele. Here, we use `MapExample`, a dataframe containing three essential columns: `ID`, `REF`, and `ALT`. This setup provides the necessary reference and alternative allele data to enable accurate variant analysis.
```{r Variant Map}
# load the variant map
data("MapExample")
# show the data
kable(head(MapExample), "html") %>% kable_styling("striped") %>% scroll_box(width = "100%")

# create the variant dataframe by adding the variant ID to the DNA and RNA counts 
var_df <- create_var_df(BcSetExample, MapExample)
# show the data
kable(head(var_df), "html") %>% kable_styling("striped") %>% scroll_box(width = "100%")

```

Optionally, downsampling can be performed to `var_df` now. The function `downsample_barcodes` allows users to reduce the number of barcodes while retaining a representative subset. So the number of barcodes of oligos with many barcodes are reduced which simplifies the data handling and reduces the sparseness of the data table (i.e. increased speed and reduced memory requirements). The degree of downsampling can be controlled by adjusting the sampling rate, which is expressed as a percentile value `percentile`. A rate of 0.5 would keep half of the original barcode counts. The default value for `percentile` is set to 0.95.
The `id_column_name` argument specifies the column in the input data frame that contains the unique identifiers for each variant (here `variant_id`).

```{r Variant Downsampling}
var_df <- downsample_barcodes(var_df, id_column_name="variant_id")
```

After downsampling the barcode counts in our dataset, we can prepare the data for analysis using the `create_dna_df` and `create_rna_df` functions. These functions help in formatting the data appropriately for further analysis in the MPRA context. Only six rows are shown here (original size of the dataframe 996 Ã— 474).
```{r Creating dna dataframe from var_df}
dna_var <- create_dna_df(var_df)
kable(head(dna_var), "html") %>% kable_styling("striped") %>% scroll_box(width = "100%")
```
```{r Creating rna dataframe from var_df}
rna_var <- create_rna_df(var_df)
kable(head(rna_var), "html") %>% kable_styling("striped") %>% scroll_box(width = "100%")
```
Now we create the MPRA set we need in the analysis.

```{r Variant MPRASet}
# create the variant specific MPRAset
BcVariantMPRASetExample <- MPRASet(DNA = dna_var, RNA = rna_var, eid = row.names(dna_var), barcode = NULL)
```

## Element testing

The dataset is the same we used above, but we have to add labels to the data to distinguish between control and test groups. Thus allowing us to easily identify and compare these different groups in the analysis later.
```{r LabelsVec}
data(LabelExample)
table(LabelExample)
kable(head(LabelExample), "html") %>% kable_styling("striped") %>% scroll_box(width = "100%")
```

We can also perform downsampling on this dataset using the `downsample_barcodes` function once again.
```{r Downsampling}
elem_df <- downsample_barcodes(BcSetExample)
```

As before, we use `create_dna_df` and `create_rna_df` to format the data correctly for the `MPRASet` function. However, this time we specify `id_column_name = "name"` since the default, `id_column_name = "variant_id"`, does not match our data format.
```{r Creating dataframes}
dna_elem <- create_dna_df(elem_df, id_column_name="name")
rna_elem <- create_rna_df(elem_df, id_column_name="name")
```

We still need to add the labels to the MPRASet, which is allowed by the BCalm MPRASet definition.

```{r Element MPRASet}
BcLabelMPRASetExample <- MPRASet(DNA = dna_elem, RNA = rna_elem, eid = row.names(dna_elem), barcode = NULL, label=LabelExample)
```

With the data now prepared and preprocessed, we now have the foundation to conduct our analysis effectively.

# Analysis
In this section we get to see the usage of the `mpralm` and the `fit_elements` functions. We take the `MPRASet` created in the preprocessing chapter. BCalm allows us to analyze individual barcode counts as separate samples, capturing additional data variation and potentially increasing statistical power.

## Variant Analysis
We will start with variant testing. In order to achieve this, we employ the `mpralm` function. Which column belongs to which replicate is described in a blocking vector, also used to normalize the counts per replicate.
The design matrix gives information which count comes from the reference and which from the alternative allele.

```{r Fit Variants}
bcs <- ncol(dna_var) / nr_reps
design <- data.frame(intcpt = 1, alt = grepl("alt", colnames(BcVariantMPRASetExample)))
block_vector <- rep(1:nr_reps, each=bcs)
mpralm_fit_var <- mpralm(object = BcVariantMPRASetExample, design = design, aggregate = "none", normalize = TRUE, model_type = "corr_groups", plot = FALSE, block = block_vector)

top_var <- topTable(mpralm_fit_var, coef = 2, number = Inf)
kable(head(rna_var), "html") %>% kable_styling("striped") %>% scroll_box(width = "100%")
```

```{r Volcano Plot}
ggplot(top_var, aes(x = logFC, y = -log10(P.Value))) +
  geom_point(alpha = 0.6)
```

## Element Analysis

BCalm provides the function `fit_elements`. It takes the `MPRASet` object as input and applies the statistical modeling. Again the `block_vector` gives reference which barcode belongs to which replicate.
Also we set `normalize = TRUE` to perform total count normalization on the RNA and DNA libraries.

```{r Fit elements, fig.width=8, fig.height=4}
bcs <- ncol(dna_elem) / nr_reps
block_vector <- rep(1:nr_reps, each=bcs)
mpralm_fit_elem <- fit_elements(object = BcLabelMPRASetExample, normalize=TRUE, block = block_vector, plot = FALSE)
```

### Visualisation and results
In this section, we will examine the visualization of our analysis results using the `mpra_treat` and `plot_groups` functions. By employing these functions, we can create representations of differences between groups in our MPRA data that highlight important trends and patterns.
To visualize our results, we utilize the `plot_groups` function, which allows us to compare logratios for each group. We use the results we got from `fit_elements` above, as it contains the statistical data which is needed for visualization. As negative controls we use `"control"` and as test `"tested"`.

```{r Visualization, fig=TRUE, fig.width=8, fig.height=4, warning=FALSE}
plot_groups(mpralm_fit_elem, 0.975, neg_label="control", test_label="tested")
```

The `mpra_treat()` function is a wrapper around the `treat()` and `topTreat()` functions from the LIMMA package. This function performs a t-test with a specified threshold, making it especially useful for identifying elements with significant differential activity in MPRA data.
```{r MPRA treat}
result <- mpra_treat(mpralm_fit_elem, 0.975, neg_label="control")
head(result)
```

# Session Info

```{r sessionInfo, results='asis', echo=FALSE}
sessionInfo()
```

# References